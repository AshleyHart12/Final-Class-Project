{"ast":null,"code":"const COLORS = [0, 1, 2, 3, 4];\n\nconst randomIndexFromCollection = collection => {\n  var index = 0;\n\n  for (var i = 1, max = collection.length; i < max; i++) {\n    if (Math.random() < 1 / (i + 1)) {\n      index = i;\n    }\n  }\n\n  return index;\n};\n\nclass Node {\n  constructor(id, color) {\n    this.id = id;\n    this.color = color;\n  }\n\n}\n\nclass Edge {\n  constructor(sourceId, destId, weight) {\n    this.sourceId = sourceId;\n    this.destId = destId;\n    this.weight = weight;\n  }\n\n}\n\nclass Graph {\n  constructor(size = 3) {\n    this.size = size;\n    this.nodes = {};\n    this.edgesByNode = {};\n\n    for (let i = 0; i < size * size; i++) {\n      this.nodes[i] = new Node(i, randomIndexFromCollection(COLORS));\n    }\n\n    this.setEdgeWeights();\n  }\n\n  setEdgeWeight(id) {\n    let node = this.nodes[id];\n    let nodeId = node.id;\n    let edges = [];\n    let topIndex = nodeId - this.size;\n    let rightIndex = nodeId + 1;\n    let bottomIndex = nodeId + this.size;\n    let leftIndex = nodeId - 1;\n\n    if (topIndex >= 0) {\n      let w = this.sameColor(nodeId, topIndex) ? 0 : 1;\n      edges.push(new Edge(nodeId, topIndex, w));\n    }\n\n    if (rightIndex % this.size > 0) {\n      let w = this.sameColor(nodeId, rightIndex) ? 0 : 1;\n      edges.push(new Edge(nodeId, rightIndex, w));\n    }\n\n    if (bottomIndex < this.size * this.size) {\n      let w = this.sameColor(nodeId, bottomIndex) ? 0 : 1;\n      edges.push(new Edge(nodeId, bottomIndex, w));\n    }\n\n    if (nodeId % this.size !== 0) {\n      let w = this.sameColor(nodeId, leftIndex) ? 0 : 1;\n      edges.push(new Edge(nodeId, leftIndex, w));\n    }\n\n    this.edgesByNode[nodeId] = edges;\n  }\n\n  setEdgeWeights() {\n    Object.keys(this.nodes).forEach(id => {\n      this.setEdgeWeight(id);\n    });\n  }\n\n  updateColor(id, color) {\n    this.nodes[id].color = color;\n  }\n\n  colorFill(color) {\n    let seenIds = [];\n    let processing = [0]; // starting at the top left corner (this is a stack)\n\n    let updateEdgeWeights = [];\n\n    while (processing.length > 0) {\n      let currentNodeId = processing.pop();\n      this.updateColor(currentNodeId, color);\n      seenIds.push(currentNodeId);\n      this.edgesByNode[currentNodeId].forEach(edge => {\n        if (seenIds.indexOf(edge.destId) > -1) {\n          return; // bail if we've seen it\n        }\n\n        if (edge.weight === 0) {\n          processing.push(edge.destId); // process it there is no weight cost\n        }\n\n        if (edge.weight === 1 && this.nodes[currentNodeId].color === color) {\n          updateEdgeWeights.push(currentNodeId); // update the edge weghts after we finish color filling\n        }\n      });\n    }\n\n    updateEdgeWeights.forEach(nodeId => this.setEdgeWeight(nodeId)); // BUG: The graph is now in a state that works but not all edges are accurate.\n  }\n\n  sameColor(nodeAId, nodeBId) {\n    return this.nodes[nodeAId].color === this.nodes[nodeBId].color;\n  }\n\n}\n\nexport { Graph }; // update a node's color\n// which will update the weights of the nodes.\n// i can update colors and *then* update the weights","map":{"version":3,"sources":["/Users/ashinator/code/Final-Class-Project/client/src/components/pages/GameApp/Graph.js"],"names":["COLORS","randomIndexFromCollection","collection","index","i","max","length","Math","random","Node","constructor","id","color","Edge","sourceId","destId","weight","Graph","size","nodes","edgesByNode","setEdgeWeights","setEdgeWeight","node","nodeId","edges","topIndex","rightIndex","bottomIndex","leftIndex","w","sameColor","push","Object","keys","forEach","updateColor","colorFill","seenIds","processing","updateEdgeWeights","currentNodeId","pop","edge","indexOf","nodeAId","nodeBId"],"mappings":"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","sourcesContent":["const COLORS = [0,1,2,3,4]; \n\nconst randomIndexFromCollection = (collection) => {\n  var index = 0;\n  for (var i = 1, max = collection.length; i < max; i++) {\n    if (Math.random() < 1/(i+1)) {\n      index = i;\n    }\n  }\n  return index;\n}\n\nclass Node {\n  constructor(id, color) {\n    this.id = id;\n    this.color = color;\n  }\n}\n\nclass Edge {\n  constructor(sourceId, destId, weight) {\n    this.sourceId = sourceId;\n    this.destId = destId;\n    this.weight = weight;\n  }\n}\n\nclass Graph {\n  constructor(size=3) {\n    this.size = size;\n    this.nodes = {};\n    this.edgesByNode = {};\n    for (let i=0; i<size*size; i++) {\n      this.nodes[i] = new Node(i, randomIndexFromCollection(COLORS));\n    }\n    this.setEdgeWeights();\n  }\n\n  setEdgeWeight(id) {\n      let node = this.nodes[id];\n      let nodeId = node.id;\n\n      let edges = [];\n\n      let topIndex = nodeId - this.size;\n      let rightIndex = nodeId + 1;\n      let bottomIndex = nodeId + this.size;\n      let leftIndex = nodeId - 1;\n\n      if (topIndex >= 0) {\n        let w = this.sameColor(nodeId, topIndex) ? 0 : 1;\n        edges.push(new Edge(nodeId, topIndex, w));\n      }\n\n      if (rightIndex % this.size > 0) {\n        let w = this.sameColor(nodeId, rightIndex) ? 0 : 1;\n        edges.push(new Edge(nodeId, rightIndex, w));\n      }\n\n      if (bottomIndex < this.size * this.size) {\n        let w = this.sameColor(nodeId, bottomIndex) ? 0 : 1;\n        edges.push(new Edge(nodeId, bottomIndex, w));\n      }\n\n      if (nodeId % this.size !== 0) {\n        let w = this.sameColor(nodeId, leftIndex) ? 0 : 1;\n        edges.push(new Edge(nodeId, leftIndex, w));\n      }\n\n      this.edgesByNode[nodeId] = edges;\n  }\n\n  setEdgeWeights() {\n    Object.keys(this.nodes).forEach((id) => {\n      this.setEdgeWeight(id);\n    });\n  }\n\n  updateColor(id, color) {\n    this.nodes[id].color = color;\n  }\n\n  colorFill(color) {\n    let seenIds = [];\n    let processing = [0]; // starting at the top left corner (this is a stack)\n    let updateEdgeWeights = [];\n    while (processing.length > 0) {\n      let currentNodeId = processing.pop();\n      this.updateColor(currentNodeId, color);\n      seenIds.push(currentNodeId);\n      this.edgesByNode[currentNodeId].forEach((edge) => {\n        if (seenIds.indexOf(edge.destId) > -1) {\n          return; // bail if we've seen it\n        }\n        if (edge.weight === 0) {\n          processing.push(edge.destId); // process it there is no weight cost\n        }\n        if (edge.weight === 1 && this.nodes[currentNodeId].color === color) {\n          updateEdgeWeights.push(currentNodeId); // update the edge weghts after we finish color filling\n        }\n      });\n    }\n    updateEdgeWeights.forEach((nodeId) => this.setEdgeWeight(nodeId));\n    // BUG: The graph is now in a state that works but not all edges are accurate.\n  }\n\n  sameColor(nodeAId, nodeBId) {\n    return this.nodes[nodeAId].color === this.nodes[nodeBId].color;\n  }\n}\n\nexport { Graph };\n// update a node's color\n// which will update the weights of the nodes.\n// i can update colors and *then* update the weights\n"]},"metadata":{},"sourceType":"module"}